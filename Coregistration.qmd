---
title: "Coregistration"
author: "Dan"
date: today
format: gfm
editor: visual
execute:
  echo: false
bibliography: references.bib
---

Our goal is to identify landslide sites using changes in ground-surface elevation resolved between sequential lidar acquisitions. We want to take advantage of raster-processing algorithms for image segmentation and topographic analyses, so we would like to work with elevation-difference rasters. In using lidar to detect elevation change, it is necessary to ensure that the two data sets are aligned spatially. Differences in spatial registration between the two data sets will produce systematic errors in measured elevation differences. In the study design, we described approaches that have been used for co-registration of lidar datasets. These involve two strategies:

-   Co-register the ground returns, then build DTMs.

-   Co-register existing DTMs.

The first approach seems likely to be the more consistent of the two, because consistent methods can be used for filtering ground returns from the point clouds and for interpolation of the DTMs from the ground returns. When using existing DTMs, e.g., those downloaded from the [Washington Lidar Portal](https://lidarportal.dnr.wa.gov/), they may have been generated with different point-filtering algorithms and interpolation schemes. However, working with point clouds directly is computationally intensive and time consuming. If we can obtain good results with the existing DTMs, that will reduce time and computer requirements dramatically [@li2023].

Consider two DTMs for the same site. One may be slightly shifted horizontally and vertically from the other, and/or slightly tilted or rotated. Over all or some portion of the DTMs, we can seek to shift and rotate one so as to minimize differences with the other [@d.rosenholm1988]. We assume that, over the spatial extents of aerial lidar acquisitions (as opposed to those of satellite-acquired lidar), registration of the point clouds and derived surface models is sufficiently accurate that differences in the tilt and rotation of the coordinate systems is minimal. We focus on a linear displacement of one DTM from the other by an amount $\Delta x, \Delta y, \Delta z$. Writing the elevation difference between the two DTMs at a grid-point $i$ as $\Delta e_i$, we can write the elevation difference as

$$
\Delta e_i = \frac{\partial{\Delta e_i}}{\partial{x_i}}\Delta x + \frac{\partial{\Delta e_i}}{\partial{y_i}}\Delta y + \frac{\partial{\Delta e_i}}{\partial{z_i}}\Delta z
$$ {#eq-shifts}

where $\frac{\partial{\Delta e_i}}{\partial{x_i}}$ is the partial derivative of the elevation difference with respect to $x_i$, and similarly for $y_i$ and $z_i$. For $n$ DTM grid points, we then have $n$ equations, each with a unique $\Delta e_i, \frac{\partial{\Delta e_i}}{\partial{x_i}}$, and $\frac{\partial{\Delta e_i}}{\partial{y_i}}$ ($\frac{\partial{\Delta e_i}}{\partial{z_i}}$ is simply one) and with single values for each of $\Delta x, \Delta y$, and $\Delta z$. We seek the $\Delta x, \Delta y$, and $\Delta z$ that provide the best estimates of all the $\Delta e_i$. We can treat this as a [linear least-squares problem](https://en.wikipedia.org/wiki/Linear_least_squares). In matrix notation, we seek to minimize $||\boldsymbol{A}\boldsymbol{x} - \boldsymbol{b}||^2$ where $\boldsymbol{A}$ is a 3 by $n$ matrix containing the partial derivatives, $\boldsymbol{x}$ is a 3-element vector containing the the $\Delta x, \Delta y$, and $\Delta z$ values, and $\boldsymbol{b}$ is an $n$-element array containing the $\Delta e_i$.

Imagine, on an 80% slope, an offset of 0.5 meters between the two DTMs would result in a $\Delta e$ of 0.4 meters. The partial derivatives $\frac{\partial{\Delta e_i}}{\partial{x_i}}$ and $\frac{\partial{\Delta e_i}}{\partial{y_i}}$ reflect the ground-surface slope at point $i$ as resolved by the DTM. Each point lies at the corner of four DTM cells, each cell is defined by four points. For any DTM point, we can look at the elevations of the adjacent 8 points to determine into which of the four adjacent cells we need to shift the point to solve for $\Delta e$. We can estimate the elevation change with a change in $x$ or $y$ within that cell using bilinear interpolation. That gives a value for $\frac{\partial{\Delta e_i}}{\partial{x_i}}$ and $\frac{\partial{\Delta e_i}}{\partial{y_i}}$. The value of $\frac{\partial{\Delta e_i}}{\partial{z_i}}$ is simply 1.[^1]

[^1]: I found, however, that the vertical shift, $\Delta z$, varied nonlinearly with slope gradient. @eq-shifts was therefore modified to $\Delta e_i =\frac{\partial{\Delta e_i}}{\partial{x_i}}\Delta x + \frac{\partial{\Delta e_i}}{\partial{y_i}}\Delta y + \frac{\partial{\Delta e_i}}{\partial{z_i}}\Delta z + \beta_1 S_i + \beta_2 S_i^2$, where $S_i$ is the sine of the hillslope gradient for the $i^{th}$ point and $\beta_1$ and $\beta_2$ are additional empirical coefficients.

For any overlapping portion of two DTMs, we can find an optimal set $\Delta x, \Delta y$, and $\Delta z$. In doing this, we want to exclude portions of the DTMs where elevation changes did occur. The $\Delta e$ values for those sites would not be a consequence of a shift in the registration between the DTMs and including those in our set of equations would bias the resulting estimates for $\Delta x, \Delta y$, and $\Delta z$. Below I describe a method for differentiating systematic errors and noise from the elevation changes we want to resolve.

We'll use a portion of the Post-Mortem study area with overlap of the 2006 and 2007 lidar DTMs that contains several of the study blocks. The study blocks are shown by the black polygons in the image below. The red box outlines the analysis area.

![](images/clipboard-1274792243.png)

![Site location and area of analysis.](images/clipboard-3673670531.png){#fig-site fig-cap="Site location and area of analysis"}

Overlap of the two DTMs is shown below with the elevation difference, in quarter-meter increments, indicated by the colors.

![Elevation difference (m), 2006 to 2017 lidar overlap](images/clipboard-2801040071.png){#fig_dif0 fig-cap="Elevation difference (m), 2006 to 2017 lidar overlap" fig-align="center"}

The elevation differences are spatially variable with systematic biases aligned with hillslope aspect. We can see this by binning the elevation differences for each DTM grid point by increments in slope and aspect and plotting [quartiles](https://en.wikipedia.org/wiki/Quartile). To make the following plots, I first determined the quartiles for the full range of elevation-difference values in each bin. I want to focus on systematic errors and noise in the DTMs and exclude sites where elevations did change, e.g., at landslide sites. To differentiate between signal (actual elevation changes) and noise, I calculated the interquartile range for all values, then used a [Tukey fence](https://en.wikipedia.org/wiki/Outlier#Tukey's_fences) with $k$ = 1.5. Values less that $q1 - 1.5*(q3-q1)$ or greater than $q3 + 1.5*(q3-q1)$ are considered likely [outliers](https://en.wikipedia.org/wiki/Outlier). These potentially indicate sites where elevations have changed between lidar acquisitions. For each bin, I removed these potential outliers and recalculated the quartiles to provide an estimate of the systematic bias and random error in the elevation-difference values.

The calculations are performed by program Align.

```{r}
# Run program Align

library(TerrainWorksUtils)
library(stringr)

inputPath <- "c:/work/data/postmortem/"
refDTM <- paste0(inputPath, "elev_2006N.flt") # reference DTM, pre landslide
alignDTM <- paste0(inputPath, "elev_2017N.flt") # DTM to be aligned, post landslide
refDSM <- paste0(inputPath, "dsm2006N.flt") # reference DSM, pre landslide
alignDSM <- paste0(inputPath, "dsm2017N.flt") # DSM to be aligned, post landslide
iterations <- 4 # number of times to repeat the alignment calculation
k <- 1.5 # k <= 0, smaller values filter more points as outliers
dampener <- 1.0 # proportion of calculated shift to apply with each iteration
outDTM <- paste0(inputPath, "elev_2017Naligned0") # output aligned DTM
tileNx <- 0 # number of tiles in x (east-west) direction
tileNy <- 0 # number of tiles in y (north-south) direction
overlap <- 0.5 # overlap between tiles
radius <- 15. # radius (m) for calculating slope and aspect
nslope <- 7 # number of slope bins
maxSlope <- 1.0 # maximum slope gradient to include in bins
nAzimuth <- 8 # number of aspect bins
outbins <- paste0(inputPath, "outbins0") # output csv file names
outDif <- paste0(inputPath, "difN0") # output difference raster
outOutlier <- paste0(inputPath, "outlierN0")
scratch_dir <- "c:/work/scratch"
executable_dir <- "c:/work/sandbox/gridutilities/projects/align/x64/release/"
program_name = "align"

returnCode <- TerrainWorksUtils::align(refDTM,
               alignDTM,
               refDSM,
               alignDSM,
               iterations,
               k,
               dampener,
               outDTM,
               tileNx,
               tileNy,
               overlap,
               radius,
               nslope,
               maxSlope,
               nAzimuth,
               outbins,
               outDif,
               outOutlier,
               scratch_dir,
               executable_dir,
               program_name)

if (returnCode != 0) {
  stop("Error in align")
}
```

@fig-medianErrorBefore shows median elevation difference values across the range of hillslope gradient and aspect increments. Deviations from zero indicate systematic variations with gradient and aspect.

```{r}
#| label: fig-medianErrorBefore
#| fig-cap: "Median difference (m) in 2006 and 2017 DTM elevations prior to coregistration, after removal of apparent outliers."

library(data.table)
library(ggplot2)
library(patchwork)
library(RColorBrewer)

datafile <- paste0(outbins,"_0.csv")
e0 <- as.data.table(read.csv(datafile))
e0 <- e0[, "Aspect" := as.factor(Azimuth)]
e0 <- e0[, "Gradient" := tan(asin(Slope))]
e0 <- e0[, "Gradient" := as.factor(Gradient)]

pq2_slope <- ggplot(e0, aes(x=tan(asin(Slope)), y=Q2, color=Aspect)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Gradient', 
       y='Median Error (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1',
                     labels=c("N","NE","E","SE","S","SW","W","NW")) +
  scale_x_continuous(labels=scales::percent) +
  coord_cartesian(y=c(-1,1))

pq2_aspect <- ggplot(e0, aes(x=Azimuth, y=Q2, color=Gradient)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Aspect (degrees)', 
       y='Median Error (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1', 
                     labels=c("0-15%", "15-30%", "30-45%", "45-60%", "60-75%", "75-90%", "90-100%")) +
  scale_x_continuous(breaks=seq(0,315,45), 
                     minor_breaks=NULL) +
  coord_cartesian(y=c(-1,1))

pq2 <- pq2_slope / pq2_aspect
pq2 <- pq2 + plot_annotation(title = "Median elevation differences (m) prior to coregistration")
pq2
```

This systematic error is small for low-gradient terrain and increases with slope steepness. For south-easterly aspects, the median error is negative; for north-westerly aspects, the median error is positive, and for south-west and north-east facing slopes, the median error remains small. This indicates that the DTMs are shifted in a south-east to north-west direction relative to each other.

We can use the [interquartile range](https://en.wikipedia.org/wiki/Interquartile_range) as a measure of the magnitude of random variability in the difference raster.

```{r}
#| label: fig-interquartileBefore
#| fig-cap: "Interquartile range (m) of 2006 and 2017 DTM elevation differencess prior to coregistration, after removal of apparent outliers."

pinter_slope <- ggplot(e0, aes(x=tan(asin(Slope)), y=InterQuartile, color=Aspect)) +
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Gradient', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1', 
                     labels=c("N","NE","E","SE","S","SW","W","NW")) +
  scale_x_continuous(labels=scales::percent) +
  coord_cartesian(y=c(0,0.45))

pinter_aspect <- ggplot(e0, aes(x=Azimuth, y=InterQuartile, color=Gradient)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Aspect', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1',
                     labels=c("0-15%", "15-30%", "30-45%", "45-60%", "60-75%", "75-90%", "90-105%")) +
  scale_x_continuous(breaks=seq(0,315,45), 
                     minor_breaks=NULL) +
  coord_cartesian(y=c(0,0.45))

pinter <- pinter_slope / pinter_aspect
pinter <- pinter + plot_annotation(title = "Interquartile range (m) prior to coregistration")
pinter
```

The interquartile range is relatively small for low-gradient terrain and increases with slope steepness. This provides a characterization of the noise in the elevation-difference raster obtained by subtracting the 2017 lidar DTM from the 2006 lidar DTM. Can we use these measurements to constrain the elevation-threshold that distinguishes signal from noise? Can we use $qmin = q1 - 1.5*(q3-q1)$ for the minimum $q1$ value as a function of aspect and slope as a threshold for identifying sites where elevations decreased between 2006 and 2017? Likewise, can we use $qmax = q3 + 1.5*(q3-q1)$ for the maximum $q3$ value as a function of aspect and slope as a threshold for identifying sites where elevations increased between 2006 and 2017? These values provide slope-dependent threshold within which we can identify sites where elevations likely did not change.

Can we define a function of slope and aspect that reflects the behavior observed in the graphs above? For a single aspect, we see that the median error exhibits a slightly curved dependence with gradient. The slope of that linear dependence varies with the sine of the aspect. This agrees with what we expect if the two DTMs are offset horizontally. Along the fall line, differences in elevation will be maximum; along a contour, differences will be minimum. We define

$$\mu = \sin(A+\alpha)$$

where $A$ is the azimuth measured from north and $\alpha$ is the angular shift so variation in $\mu$ aligns with that seen in @fig-medianErrorBefore. Then define a linear function of gradient with coefficients that vary with $\mu$:

$$
qmin = (\beta_0 + \beta_1\mu) + (\beta_2 + \beta_3\mu)S + (\beta_4 + \beta_5 \mu)S^2
$$

where $S$ is slope gradient and the $\beta$ are empirical coefficients. This defines an equation with seven coefficients, $\alpha$ and the six $\beta$ values.

I solve for these coefficients as follows:

1.  Create a normalized set of curves for the variation of $q2$ as a function of aspect for each of the slope-gradient increments. The "normalized" curves vary from -1 to +1 over the range of aspects. The normalization is done as follows:
    i)  For each slope increment, find the maximum and minimum values of $q2$.
    ii) Define $qshift = -(qmax-qmin)*0.5$
    iii) Define $range = (qmax-qmin)*0.5$
    iv) Define $normq(abin,sbin) = (q2(abin,sbin) + qshift)/range$
2.  Find the value of $\alpha$ that minimizes the sum of squared residuals, i.e., find the value of $\alpha$ that minimizes $\sum_{i=1}^n(\sin(A_i+\alpha)-normq_i)^2$. This is done using Brent's algorithm (see [people.match.sc.edu/Burkardt/f_src/brent/brent.f90](https://people.math.sc.edu/Burkardt/f_src/brent/brent.f90)).
3.  Define a set of linear equations\
    $$qmin_i = \beta min_0 + \beta min_1*mu_i + \beta min_2*S_i + \beta min_3*mu_i*S_i$$ $$qmax_i = \beta max_0 + \beta max_1*mu_i + \beta max_2*S_i + \beta max_3*mu_i*S_i$$ where $\mu_i = \sin(A_i+\alpha)$ and $A_i$ is the slope aspect and $S_i$ is slope gradient.
4.  Solve for the $\beta min$ and $\beta max$ values. This is done using the [LAPACK](https://en.wikipedia.org/wiki/LAPACK) routine DGELS.

Here are the resulting curves for the eight major slope aspects (N, NE, E, SE, S, SW, W, and NW).

```{r}
#| label: fig-curves0
#| fig-cap: "Hillslope gradient- and aspect-dependent level of detection (LoD). The dots indicate calculated first and third quartiles for each slope and aspect interval, the thin lines show the polynomial fit to those points, and the thick lines show the Tukey's fences using a k value of 1.5."
#| fig-height: 9.5

e0[, "qmin" := Q1 - k*(Q3-Q1)]
e0[, "qmax" := Q3 + k*(Q3-Q1)]
qfit <- as.data.table(read.csv(paste0(outbins,"_fit0.csv")))
qfit <- qfit[, "Aspect" := as.factor(Azimuth)]
qfit <- qfit[, "Gradient" := tan(asin(Slope))]
qfit <- qfit[, "Gradient" := as.factor(Gradient)]

p0 <- ggplot() +
  geom_point(data=e0[Aspect==0,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==0,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")

p45 <- ggplot() +
    geom_point(data=e0[Aspect==45,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==45,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")

 p90 <- ggplot() +
  geom_point(data=e0[Aspect==90,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==90,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
 p135 <- ggplot() +
  geom_point(data=e0[Aspect==135,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==135,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
 p180 <- ggplot() +
  geom_point(data=e0[Aspect==180,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==180,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
 p225 <- ggplot() +
   geom_point(data=e0[Aspect==225,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==225,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
 p270 <- ggplot() +
   geom_point(data=e0[Aspect==270,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==270,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
   
 p315 <- ggplot() +
   geom_point(data=e0[Aspect==315,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=e0[Aspect==315,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
p1 <- p0 + p45
p2 <- p90 + p135
p3 <- p180 + p225
p4 <- p270 + p315
p5 <- p1 / p2 / p3 / p4 + plot_layout(heights=unit(c(1.5,1.5,1.5,1.5),c("in","in","in","in")))
p5
```

The envelope contained within the thick black threshold curves defines the elevation-difference values falling within the range of gradient- and aspect-dependent systematic errors plus random variability present in the difference raster. We use these thresholds to define the level of detection [LoD, e.g., @lane2003a; @brasington2003a] to identify sites where there likely were elevation changes during the time between the lidar acquisitions and exclude these from the set of equations used to estimate the optimal $\Delta x, \Delta y$, and $\Delta z$ values with @eq-shifts above.

Note that these thresholds are not symmetric about zero. The median, midway between the Q1 and Q3 curves, is near zero for low-gradient terrain, but veers away from zero at steeper gradients by an amount that varies with aspect. Shifting the 2017 DTM to minimize differences between the two DTMs should eliminate that aspect dependence.

Here are results after coregistration.

```{r}
#| label: fig-medianErrorAfter
#| fig-cap: "Median difference (m) in 2006 and 2017 DTM elevations after coregistration."

datafile <- paste0(outbins,"_final.csv")
efinal <- as.data.table(read.csv(datafile))
efinal <- efinal[, "Aspect" := as.factor(Azimuth)]
efinal <- efinal[, "Gradient" := tan(asin(Slope))]
efinal <- efinal[, "Gradient" := as.factor(Gradient)]

pq2f_slope <- ggplot(efinal, aes(x=tan(asin(Slope)), y=Q2, color=Aspect)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Gradient', 
       y='Median Error (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1',
                     labels=c("N","NE","E","SE","S","SW","W","NW")) +
  scale_x_continuous(labels=scales::percent) +
  coord_cartesian(y=c(-1,1))

pq2f_aspect <- ggplot(efinal, aes(x=Azimuth, y=Q2, color=Gradient)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Aspect (degrees)', 
       y='Median Error (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1', 
                     labels=c("0-15%", "15-30%", "30-45%", "45-60%", "60-75%", "75-90%", "90-105%")) +
  scale_x_continuous(breaks=seq(0,315,45), 
                     minor_breaks=NULL) +
  coord_cartesian(y=c(-1,1))

pq2f <- pq2f_slope / pq2f_aspect
pq2f <- pq2f + plot_annotation(title = "Median difference in elevations (m) after coregistration")
pq2f
```

This procedure has greatly reduced the systematic differences. Let's look at the interquartile range, our measure of random error.

```{r}
#| label: fig-interquartileAfter
#| fig-cap: "Interquartile range (m) of 2006 and 2017 DTM elevation differences after coregistration."

efinal[, "InterQuartile" := Q3 - Q1]
pinterf_slope <- ggplot(efinal, aes(x=tan(asin(Slope)), y=InterQuartile, color=Aspect)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Gradient', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1', 
                     labels=c("N","NE","E","SE","S","SW","W","NW")) +
  scale_x_continuous(labels=scales::percent) +
  coord_cartesian(y=c(0,0.45))

pinterf_aspect <- ggplot(efinal, aes(x=Azimuth, y=InterQuartile, color=Gradient)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Aspect', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Set1',
                     labels=c("0-15%", "15-30%", "30-45%", "45-60%", "60-75%", "75-90%", "90-105%")) +
  scale_x_continuous(breaks=seq(0,315,45), 
                     minor_breaks=NULL) +
  coord_cartesian(y=c(0,0.45))

pinterf <- pinterf_slope / pinterf_aspect
pinterf <- pinterf + plot_annotation(title = "Interquartile range (m) after coregistration")
pinterf
```

Comparing before and after:

```{r}
#| label: fig-compareq2
#| fig-cap: Median elevation differences (m) before and after coregistration.
pq2_slope <- pq2_slope + labs(title="Before")
pq2f_slope <- pq2f_slope + labs(title="After")
compareq2 <- pq2_slope / pq2f_slope
compareq2 <- compareq2 + plot_annotation(title="Median difference (m) before and after coregistration")
compareq2
```

```{r}
#| label: fig-compareInter
#| fig-cap: "Interquartile range (m) before and after coregistration."

inter_slope <- pinter_slope + labs(title="Before")
interf_slope <- pinterf_slope + labs(title="After")
compareInter <- pinter_slope / pinterf_slope
compareInter <- compareInter + 
  plot_annotation(title="Interquartile range (m) before and after coregistration")
compareInter
```

The random errors, as indicated by the interquartile range, have been slightly reduced. Not what I was expecting. Here's another look at the before and after results.

```{r}
#| warnings: false
#| label: fig-den
#| fig-cap: "Density plots of median, mean, and interquartile range of elevation differences before and after coregistration."
pq2den <- ggplot() + 
  geom_density(data=e0, aes(x=Q2, fill="Before"), alpha=0.5) +
  geom_density(data=efinal, aes(x=Q2, fill="After"), alpha=0.5) +
  labs(x="Median error (m)",
       y="Density") +
  scale_fill_manual(breaks = c("After", "Before"),
                    values=c("Before" = 'red', "After" = 'blue')) +
  theme(legend.position = c(0.7,0.7),
        legend.title = element_blank(),
        legend.background = element_rect(fill = "transparent"))

pInterDen <- ggplot() + 
  geom_density(data=e0, aes(x=InterQuartile, fill="Before"), alpha=0.5) +
  geom_density(data=efinal, aes(x=InterQuartile, fill="After"), alpha=0.5) +
  labs(x="Interquartile (m)",
       y="Density") +
  scale_fill_manual(breaks = c("After", "Before"),
                    values=c("Before" = 'red', "After" = 'blue')) +
  theme(legend.position = c(0.8,0.8),
        legend.title = element_blank(),
        legend.background = element_rect(fill = "transparent"))

pMeanDen <- ggplot() + 
  geom_density(data=e0, aes(x=Mean, fill="Before"), alpha=0.5) +
  geom_density(data=efinal, aes(x=Mean, fill="After"), alpha=0.5) +
  labs(x="Mean (m)",
       y="Density") +
  scale_fill_manual(breaks = c("After", "Before"),
                    values=c("Before" = 'red', "After" = 'blue')) +
  theme(legend.position = c(0.8,0.8),
        legend.title = element_blank(),
        legend.background = element_rect(fill = "transparent"))

p <- pq2den / pMeanDen / pInterDen
p <- p + plot_annotation(title="Density plots before and after coregistration")
p
```

We've narrowed the range of median and mean values and shifted the interquartiles to lower values. Here's the elevation differences after alignment:

![Elevation differences (2017 minus 2006) after coregistration.](images/clipboard-292234770.png){#fig_dif fig-cap="Elevation differences (2017 minus 2006) after coregistration."}

We still see random noise, but the systematic errors aligned with slope aspect are gone. Distinct changes are visible along many stream channels. The final level of detection (LoD) used to delineate stable terrain from areas where elevations changed between 2006 and 2017 is shown with the curves in @fig-curvesFinal below.

```{r}
#| label: fig-curvesFinal
#| fig-cap: "First and third quartiles (dots), polynomial fits (thin lines), and limits using Tukey's fences (k=1.5) after shifting the 2017 DTM."
#| fig-height: 9.5
library(scales)

efinal[, "qmin" := Q1 - 1.5*(Q3-Q1)]
efinal[, "qmax" := Q3 + 1.5*(Q3-Q1)]
qfit <- as.data.table(read.csv(paste0(outbins,"_fitfinal.csv")))
qfit <- qfit[, "Aspect" := as.factor(Azimuth)]
qfit <- qfit[, "Gradient" := tan(asin(Slope))]
qfit <- qfit[, "Gradient" := as.factor(Gradient)]

p0f <- ggplot() +
  geom_point(data=efinal[Aspect==0,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==0,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==0,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")

p45f <- ggplot() +
    geom_point(data=efinal[Aspect==45,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==45,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==45,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")

p90f <- ggplot() +
  geom_point(data=efinal[Aspect==90,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==90,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==90,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
p135f <- ggplot() +
  geom_point(data=efinal[Aspect==135,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==135,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==135,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South East',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
p180f <- ggplot() +
  geom_point(data=efinal[Aspect==180,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==180,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==180,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
p225f <- ggplot() +
   geom_point(data=efinal[Aspect==225,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==225,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==225,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='South West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
 
p270f <- ggplot() +
   geom_point(data=efinal[Aspect==270,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==270,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==270,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
   
 p315f <- ggplot() +
   geom_point(data=efinal[Aspect==315,],
             aes(x=tan(asin(Slope)),y=Q1),
             size=2) +
  geom_point(data=efinal[Aspect==315,],
             aes(x=tan(asin(Slope)),y=Q3),
             size=2) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Q1fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Q3fit),
            linewidth=0.5) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Qmin),
            linewidth=1) +
  geom_line(data=qfit[Aspect==315,],
            aes(x=tan(asin(Slope)),y=Qmax),
            linewidth=1) +
  coord_cartesian(y=c(-1.6,1.6)) +
  labs(title='North West',
       x = "Gradient",
       y = "Qmin - Q1 -- Q3 - Qmax")
p1 <- p0f + p45f
p2 <- p90f + p135f
p3 <- p180f + p225f
p4 <- p270f + p315f
p5f <- p1 / p2 / p3 / p4 + plot_layout(heights=unit(c(1.5,1.5,1.5,1.5),c("in","in","in","in")))
p5f <- p5f + plot_annotation(title = "Interquartile range and LoD based on Tukey's fences (k=1.5) after coregistration")
p5f
```

The curves are now all symmetric about zero and the envelope defining the LoD is narrower. Even so, the what we are interpeting as "noise" in the DoD still spans a range of about ± 0.5m. What might be some causes of this uncertainty?

## Canopy effects.

See @fig-canopy below. The left panel shows elevation differences draped on a shaded relief image for a portion of the overlapping 2006 and 2017 DTMs after coregistration; the right panel shows an aerial photo view of the same area. Over the low-gradient, low-relief, and unforested fields and pastures, differences between the two DTMs are minor. Over the forested hillslopes, the speckled pattern in the left panel indicates variability in DTM elevations on the order of several tens of centimeters over horizontal length scales of a few to ten meters, consistent with a general reduction of lidar DTM accuracy observed over forested areas [@simpson2017].

![The left panel shows differences in DTM elevations after coregistration. The right panel shows an aerial photo view of the same area.](images/clipboard-2778201248.png){#fig-canopy fig-cap="Left panel shows differences in DTM elevations after coregistration. Right panel shows an aerial photo view of the same area."}

There are two likely primary reasons for the increased variability over forested areas [@petras2023a]:

1.  Increased spacing of lidar ground returns because of reflections from the forest canopy, and

2.  Interpretation of canopy reflections as ground returns.

The first of these is illustrated in @fig-groundReturns below.

![Left panel shows the number of lidar ground returns within each cell of the 2006 DTM (3-foot DTM point spacing). Right panel zooms into the area within the box of the left panel. Black dots indicate ground returns.](images/clipboard-1515199096.png){#fig-groundReturns fig-cap="Left panel shows the number of lidar ground returns within each cell of the 2006 DTM (3-foot DTM point spacing). Right panel zooms into the area within the box of the left panel. Black dots indicate ground returns."}

Variation in ground-return spacing results in variable-sized gaps with no returns and variable spatial density in the number of signals per DTM cell. The bar chart in @fig-barChart below shows the proportion of all cells in the 2006 DTM that overlapped the 2017 DTM containing a given number of ground returns.

```{r}
#| label: fig-barChart
#| fig-cap: "Proportion of 2006 DTM cells with a given number of ground returns"

library(data.table)
library(ggplot2)

dataFile <- "c:/work/data/postmortem/pointcount.csv"
cnt <- as.data.table(read.csv(dataFile))
cnt[, prop := Cells/sum(Cells)]
p_histo <- ggplot(cnt, aes(x=Points, y= prop)) + geom_col() +
  labs(title="Proportion of 2006 DTM cells with a given number of ground returns",
       x="Number of ground returns", y="Proportion of cells") +
  coord_cartesian(x=c(0,5)) +
  scale_y_continuous(labels = scales::percent)
p_histo

```

The variable spacing between ground returns results in variable lengths over which elevations are interpolated to the DTM grid points. Topographic detail between ground-return points is lost. The gaps in ground return points will differ between the two DTMs. In rough terrain, small features resolved in one DTM might thus be missed in the other, resulting in differences in the interpolated ground elevations. A variety of factors can result in variable lidar point spacing [@yan2023; @petras2023a]. For example, the systematic north-west to south-east trending variations in point density visible in the left panel may result from the extent of swath overlap between adjacent flight lines as the lidar was collected. Random variations in point density in forested areas may result from spatial variability in the proportion of laser signals that penetrate through the tree canopy. Additionally, some of the ground returns may actually be misinterpreted reflections from tree canopy or understory vegetation, which introduces random errors into the DTM elevations.

After coregistration of the 2006 and 2017 DTMs, we found that variability in elevation differences, as measured by the interquartile range (@fig-compareInter) ranged from about 10 to 30 centimeters, increasing with increasing hillslope gradient. @fig-interquartileCanopy below shows the same data, but here parsed by hillslope gradient and tree-canopy height. Canopy height was determined in program Align after shifting the 2017 DSM by subtracting the DTM elevation from the DSM elevation at each grid point and using the maximum of the 2006 or 2017 canopy heights.

```{r}
#| label: fig-interquartileCanopy
#| fig-cap: "Variation of the interquartile range with changes in canopy height and hillslope gradient."

ecanopy <- as.data.table(read.csv(paste0(outbins,"_canopy.csv")))
ecanopy[, "qmin" := Q1 - 1.5*(Q3-Q1)]
ecanopy[, "qmax" := Q3 + 1.5*(Q3-Q1)]
ecanopy <- ecanopy[, "Tree" := as.factor(Height)]
ecanopy <- ecanopy[, "Gradient" := tan(asin(Slope))]
ecanopy <- ecanopy[, "Gradient" := as.factor(Gradient)]

pinterc_slope <- ggplot(ecanopy, aes(x=tan(asin(Slope)), y=InterQuartile, color=Tree)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Gradient', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Spectral',
                     labels=c("< 2","5","10","15","20","25","30","35","40",">40")) +
  scale_x_continuous(labels=scales::percent) +
  coord_cartesian(y=c(0.,0.45))

pinterc_canopy <- ggplot(ecanopy, aes(x=Height, y=InterQuartile, color=Gradient)) + 
  geom_line(linewidth=1) +
  geom_point(size=2) +
  labs(x = 'Tree Height (m)', 
       y='Interquartile (m)') +
  theme(legend.position="right") +
  scale_color_brewer(palette = 'Spectral',
                     labels=c("0-15%", "15-30%", "30-45%", "45-60%", "60-75%", "75-90%", "90-105%")) +
  coord_cartesian(y=c(0.,0.45))

pinterc <- pinterc_slope / pinterc_canopy
pinterc <- pinterc + plot_annotation(title = "Interquartile range (m) after coregistration",
                                     subtitle = "as a function of canopy height")
pinterc
```

```{r}
#| label: fig-curvesCanopy
#| fig-cap: "The interquartile range and LoD (Tukey's fences with k=1.5) plotted as a function of canopy height for different increments in hillslope gradient."
#| warning: false
#| fig-height: 9.5

g1 <- ecanopy[,Gradient[1]]
p1c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g1,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g1,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g1,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g1,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g1,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g1,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 5%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g2 <- ecanopy[,Gradient[11]]
p2c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g2,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g2,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g2,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g2,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g2,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g2,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 15%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g3 <- ecanopy[,Gradient[21]]
p3c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g3,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g3,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g3,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g3,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g3,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g3,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 26%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g4 <- ecanopy[,Gradient[31]]
p4c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g4,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g4,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g4,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g4,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g4,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g4,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 38%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g5 <- ecanopy[,Gradient[41]]
p5c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g5,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g5,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g5,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g5,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g5,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g5,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 51%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g6 <- ecanopy[,Gradient[51]]
p6c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g6,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g6,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g6,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g6,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g6,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g6,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 67%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

g7 <- ecanopy[,Gradient[61]]
p7c <- ggplot() +
  geom_point(data=ecanopy[Gradient==g7,],
             aes(x=Height,y=Q1),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g7,],
              aes(x=Height,y=Q1),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_point(data=ecanopy[Gradient==g7,],
             aes(x=Height,y=Q3),
             size=2) +
  geom_smooth(data=ecanopy[Gradient==g7,],
              aes(x=Height,y=Q3),
              method="lm",
              se=FALSE,
              color="black",
              linewidth=0.5) +
  geom_smooth(data=ecanopy[Gradient==g7,],
            aes(x=Height,y=qmin),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  geom_smooth(data=ecanopy[Gradient==g7,],
            aes(x=Height,y=qmax),
            method="lm",
            se = FALSE,
            color="black",
            linewidth=1.5) +
  labs(title='Gradient 87%',
       x = "Tree Height (m)",
       y = "Qmin - Q1 -- Q3 - Qmax") +
  coord_cartesian(y=c(-0.6,0.6))

p1 <- p1c + p2c
p2 <- p3c + p4c
p3 <- p5c + p6c
p4 <- p7c + plot_spacer()
p5 <- p1 / p2 / p3 / p4 + plot_layout(heights=unit(c(1.5,1.5,1.5,1.5),c("in","in","in","in")))
p5
```

These show a minor increase with tree height at low gradients, but little variation with tree height with increasing gradient. For now I am saving incorporation of canopy height into our calculation of LoD for the next iteration of program Align.

We are using the LoD defined by these graphs to identify "stable" locations where elevations have probably not changed between the 2006 and 2017 lidar acquisitions. We used the elevation differences over these stable locations to solve for the horizontal ($\Delta x, \Delta y$) and vertical ($\Delta z$) shifts needed to bring the 2017 DTM into alignment with the 2006 DTM, using @eq-shifts. The range spanned by this LoD, ± 0.5m, is sufficient, however, to include things like flood plain or fan agradation. Likewise, there may be systematic biases in the random errors associated with lidar signal reflections from vegetation interpreted as ground returns. A plantation that grows 2 meters over that 11 years may generate larger mean positive errors in 2017 DTM elevations than in 2006 DTM elevations, resulting in a positive bias in elevation differences measured over that area. Likewise, an area harvested between 2006 and 2017 will generate a negative bias. Aerially extensive small changes in elevation and systematic changes in vegetation height and density will affect the results we obtain in solving @eq-shifts. Currently, I do not know how to identify or remove those biases.

Next: identify landslide scars using the DoD.
